\documentclass[letterpaper,10pt]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{hyperref}
\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}
\usepackage{listings}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\newcommand{\toc}{\tableofcontents}

%\usepackage{hyperref}

\def\name{Hyun Song}



%% The following metadata will show up in the PDF properties
% \hypersetup{
%   colorlinks = false,
%   urlcolor = black,
%   pdfauthor = {\name},
%   pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%   pdftitle = {CS 311 Project 1: UNIX File I/O},
%   pdfsubject = {CS 311 Project 1},
%   pdfpagemode = UseNone
% }

\parindent = 0.0 in
\parskip = 0.1 in

\begin{document}
Hyun Song
931 900 227

\section{Assignment 3 Write up}
{\LARGE Design}\\
The design I planned on and ended up using was the implmentation done on \url{https://github.com/JonathanSalwan/stuffz/blob/master/lkm_samples/crypto_aes.c}, which had simple examples on how to use crypto-aes algorithms. This design implements basic functions for alloc, set key, and encrypt/decrypting a block.\\

{\LARGE Version control Log}\\

commit e2e4fa599c9f9c9001b485079fd24d75368bfd1d\\
Author: Hyun Song <songh@oregonstate.edu>\\
Date:   Sun Nov 8 15:30:14 2015 -0800\\

    Add encryption\\

commit eda396ef9c9001b4850795a6b87956ecf416541d\\
Author: Hyun Song <songh@oregonstate.edu>\\
Date:   Sat Nov 7 20:10:03 2015 -0800\\

    device driver -no encryption\\

commit ef6b52e4fa599c9eeea7dc18a1f4fac6c40625dc\\
Author: Hyun Song <songh@oregonstate.edu>\\
Date:   Sat Nov 7 18:00:58 2015 -0800\\

    added simple block driver\\

commit b2ddbcb81714f7dba5be919b755fd24d75368bfd\\
Author: Hyun Song <songh@oregonstate.edu>\\
Date:   Fri Nov 6 17:40:53 2015 -0800\\

    initial commit\\

{\LARGE Work Log}\\

Mon (11/9/15): Finished implementing the encryption. Mostly consisted of crying while attempting to debug.\\

Sun (11/8/15): Started implementing the encryption part. Spent most of the day Trying to figure out how to use qemu...\\

Sat (11/7/15): Read through ch. 16 and ch. 2 on LLD3. Structured the file, found out sbd.c and sbull.c. Hallelujah.\\

Fri (11/06/15): Looked at the assignment, and did some research. But mainly just looked at the assignment and freaked out.\\


{\LARGE DESIGN}\\
The SSTF algorithm looks at the current head position and goes through the queue looking for the request that has the shortest distance. I added requests to the end of the queue, then figured out which one to dispatch based on the lowest difference in sector from the last.\\

{\LARGE Questions}\\

\begin{enumerate}
\item The main point of this assignment was to learn about device drivers and understand how a block device works in the Linux kernel. I wrote device driver that allocates a chunk of memory and present it as a block device.\\
\item I personally approached the problem by doing a lot of research. For this project, I relied heavily on references and examples. Thankfully, I found sbull.c (Which is used as an example on LLD3) and sbd.c which took care of most of the architecture and implementations.\\
\item For debugging, the fartest I got to was putting some printk's for when it is being written to and read from the disk. Furthermore, I incorpoated the hexdump function from \url{https://github.com/JonathanSalwan/stuffz/blob/master/lkm_samples/crypto_aes.c} before and after the encryption process. If the two datas are different, I would know that the encryption worked. To test if my device worked, I would have had to use insmod and try partitioning it. Then I would have to make filesystems, and mount the filesystems, then test the reading/writing to them. (this is where I'd use mkfs).\\
\item Honestly, I learned a lot about modules, device drivers, and block devices. Another thing is that the Krypto API isn't documented very well, and it's better to just find examples. Finally working with (implementing) drivers wasn't as hard as I thought it would be, but truthfully, I spent so much time trying to figure out how to work with qemu and gdb, I don't think I'll ever want to look back to it.\\
\end{enumerate}



%\section*{Source code:}

%\lstinputlisting{concurrency.c}
%\lstinputlisting{buffer.c}
%\lstinputlisting{buffer.h}

\end{document}
